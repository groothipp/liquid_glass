#version 460
#extension GL_EXT_shader_image_load_formatted : require

#define MAX_BLOBS 15
#define MAX_BLUR_RADIUS 8.0

struct Blob {
  float s;
  float r;
  vec2 pos;
};

layout(binding = 0) uniform image2D _RenderTarget;
layout(binding = 1) uniform image2D _PostProcessTarget;

layout(binding = 2) uniform _ShaderInfo {
  uvec2 _Dims;
  uint _BlobCount;
  float _BlobThickness;
  float _Liquidness;
  float _BlurStrength;
  vec3 _ChromaticAberration;
};

layout(binding = 3) buffer _BlobBuffer {
  Blob _Blobs[];
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

float blob_sdf(vec2 ndc, Blob blob) {
  vec2 p = ndc - blob.pos;

  float x2 = p.x * p.x;
  float y2 = p.y * p.y;
  float r2 = blob.r * blob.r;
  float R2 = x2 + y2 + blob.s * blob.s / r2 * x2 * y2;

  return sqrt(R2) - blob.r;
}

float smin(float a, float b, float k) {
  float h = max(k - abs(a - b), 0.0) / k;
  return min(a, b) - 0.25 * h * h * k;
}

vec3 blur(ivec2 index, float strength) {
  int radius = int(strength * MAX_BLUR_RADIUS);

  vec3 color = vec3(0.0);
  for (int x = -radius; x <= radius; ++x) {
    for (int y = -radius; y <= radius; ++y) {
      ivec2 i = index + ivec2(x, y);
      i = clamp(i, ivec2(0, 0), ivec2(_Dims - 1));

      color += imageLoad(_RenderTarget, i).rgb;
    }
  }

  float sample_width = 2.0 * radius + 1;
  return color / (sample_width * sample_width);
}

void main() {
  uvec2 index = gl_GlobalInvocationID.xy;
  if (!all(lessThan(index, _Dims))) return;

  vec2 uv = (vec2(index) + 0.5) / vec2(_Dims);
  vec2 ndc = 2.0 * uv - 1.0;
  ndc.x *= float(_Dims.x) / float(_Dims.y);
  ndc.y *= -1.0;

  float blended_sdf = 0.0;
  for (int i = 0; i < _BlobCount; ++i) {
    Blob b = _Blobs[i];
    float sdf = blob_sdf(ndc, b);
    blended_sdf = i == 0 ? sdf : smin(blended_sdf, sdf, _Liquidness);
  }

  float shape_mask = float(blended_sdf <= 0.0);
  float edge_mask = smoothstep(-_BlobThickness, 0.0, blended_sdf);

  vec2 refraction = mix(vec2(0.01), vec2(0.0225), edge_mask);
  uv += refraction;
  uv = clamp(uv, vec2(0.0), vec2(1.0));
  ivec2 refracted_index = ivec2(uv * vec2(_Dims));

  float blur_strength = clamp(_BlurStrength + mix(-0.2, 0.2, edge_mask), 0.0, 1.0);
  vec3 blur_color = blur(refracted_index, blur_strength);

  ivec2 red_offset = ivec2(_ChromaticAberration.r * vec2(_Dims));
  float r = imageLoad(_RenderTarget, refracted_index + red_offset).r;

  ivec2 green_offset = ivec2(_ChromaticAberration.g * vec2(_Dims));
  float g = imageLoad(_RenderTarget, refracted_index + green_offset).g;

  ivec2 blue_offset = ivec2(_ChromaticAberration.b * vec2(_Dims));
  float b = imageLoad(_RenderTarget, refracted_index + blue_offset).b;

  vec3 aberration_color = vec3(r, g, b);

  vec3 shape_color = blur_color + aberration_color * edge_mask;
  vec3 background_color = imageLoad(_RenderTarget, ivec2(index)).rgb;

  vec3 albedo = mix(background_color, shape_color, shape_mask);

  imageStore(_PostProcessTarget, ivec2(index), vec4(albedo, 1.0));
}