#version 460

struct Blob {
  float s;
  float r;
  vec3 col;
  vec2 pos;
  vec2 vel;
  vec2 accel;
};

layout(binding = 0) uniform _PhysicsInfo {
  uvec2 _Dims;
  uint _BlobCount;
  float _DeltaTime;
  vec2 _MousePos;
  uint _DraggedIndex;
  float _Friction;
  float _TensionGamma;
  vec2 _TensionBounds;
};

layout(binding = 1) buffer _BlobsBuffer {
  Blob _Blobs[];
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
  uint index = gl_GlobalInvocationID.x;
  Blob b = _Blobs[index];

  b.accel = vec2(0.0);

  if (_DraggedIndex == index) {
    vec2 dx = _MousePos - b.pos;
    if (length(dx) < 1e-6)
      dx = vec2(0.0);
    b.accel = 0.5 * dx;
  }
  b.accel -= _Friction * b.vel;

  for (int i = 0; i < _BlobCount; ++i) {
    if (i == index) continue;

    Blob a = _Blobs[i];

    vec2 dL = a.pos - b.pos;
    float L = length(dL);

    float min_radius = (a.r + b.r) * _TensionBounds.x;
    float max_radius = (a.r + b.r) * _TensionBounds.y;
    if (L > min_radius && L < max_radius) {
      vec2 dir = dL / L;
      float t = smoothstep(min_radius, max_radius, L);
      b.accel += dir * (1.0 - t) * _TensionGamma;
    }
  }

  b.vel += b.accel * _DeltaTime;
  if (length(b.vel) < 1e-6)
    b.vel = vec2(0.0);

  vec2 prev_pos = b.pos;
  b.pos += b.vel * _DeltaTime;

  float ar = float(_Dims.x) / float(_Dims.y);

  if (b.pos.x - b.r < -ar) {
    b.pos.x = -ar + b.r;
    b.vel.x *= -1;
  }
  else if (b.pos.x + b.r > ar) {
    b.pos.x = ar - b.r;
    b.vel.x *= -1;
  }

  if (b.pos.y - b.r < -1.0) {
    b.pos.y = -1.0 + b.r;
    b.vel.y *= -1;
  }
  else if (b.pos.y + b.r > 1.0) {
    b.pos.y = 1.0 - b.r;
    b.vel.y *= -1;
  }

  _Blobs[index] = b;
}